<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Adventures with the ESP32 | StuartsProjects</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Adventures with the ESP32" />
<meta name="author" content="Stuart" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="As part of a project to check if locally generated electromagnetic interference (EMI) would affect LoRa receiver performance at its weak signal limits I needed a ESP32 board that I could plug Mikrobus modules into. Faster micro controllers, such as the ESP32 are becoming the norm, which is understandable, they are cheap, fast, have lots of memory and in the case of the ESP32, have built in Wifi and Bluetooth. Faster micro controllers, however, generate more EMI, so I wanted to do a LoRa reception comparison with various micro controllers. For the comparison to be valid I needed to use the same LoRa module for different controller boards, the easiest way to achieve that was to have the LoRa device on a plug in Mikrobus board, there are some details of Mikrobus modules here;" />
<meta property="og:description" content="As part of a project to check if locally generated electromagnetic interference (EMI) would affect LoRa receiver performance at its weak signal limits I needed a ESP32 board that I could plug Mikrobus modules into. Faster micro controllers, such as the ESP32 are becoming the norm, which is understandable, they are cheap, fast, have lots of memory and in the case of the ESP32, have built in Wifi and Bluetooth. Faster micro controllers, however, generate more EMI, so I wanted to do a LoRa reception comparison with various micro controllers. For the comparison to be valid I needed to use the same LoRa module for different controller boards, the easiest way to achieve that was to have the LoRa device on a plug in Mikrobus board, there are some details of Mikrobus modules here;" />
<link rel="canonical" href="http://localhost:4000/2018/03/22/adventures-with-the-esp32.html" />
<meta property="og:url" content="http://localhost:4000/2018/03/22/adventures-with-the-esp32.html" />
<meta property="og:site_name" content="StuartsProjects" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-22T00:00:00+00:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2018/03/22/adventures-with-the-esp32.html","author":{"@type":"Person","name":"Stuart"},"headline":"Adventures with the ESP32","dateModified":"2018-03-22T00:00:00+00:00","datePublished":"2018-03-22T00:00:00+00:00","description":"As part of a project to check if locally generated electromagnetic interference (EMI) would affect LoRa receiver performance at its weak signal limits I needed a ESP32 board that I could plug Mikrobus modules into. Faster micro controllers, such as the ESP32 are becoming the norm, which is understandable, they are cheap, fast, have lots of memory and in the case of the ESP32, have built in Wifi and Bluetooth. Faster micro controllers, however, generate more EMI, so I wanted to do a LoRa reception comparison with various micro controllers. For the comparison to be valid I needed to use the same LoRa module for different controller boards, the easiest way to achieve that was to have the LoRa device on a plug in Mikrobus board, there are some details of Mikrobus modules here;","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/03/22/adventures-with-the-esp32.html"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="StuartsProjects" />
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">StuartsProjects</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/Contact.html">Contact</a><a class="page-link" href="/Products.html">Products</a><a class="page-link" href="/WhatisLora.html">What Is LoRa ?</a><a class="page-link" href="/about.html">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Adventures with the ESP32</h1>
    <p class="post-meta"><time class="dt-published" datetime="2018-03-22T00:00:00+00:00" itemprop="datePublished">
        Mar 22, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>As part of a project to check if locally generated electromagnetic interference (EMI) would affect LoRa receiver performance at its weak signal limits I needed a ESP32 board that I could plug Mikrobus modules into. Faster micro controllers, such as the ESP32 are becoming the norm, which is understandable, they are cheap, fast, have lots of memory and in the case of the ESP32, have built in Wifi and Bluetooth. Faster micro controllers, however, generate more EMI, so I wanted to do a LoRa reception comparison with various micro controllers. For the comparison to be valid I needed to use the same LoRa module for different controller boards, the easiest way to achieve that was to have the LoRa device on a plug in Mikrobus board, there are some details of Mikrobus modules here;</p>

<p><a href="https://www.mikroe.com/blog/mikrobus-is-growing-and-its-everywhere" title="https://www.mikroe.com/blog/mikrobus-is-growing-and-its-everywhere">https://www.mikroe.com/blog/mikrobus-is-growing-and-its-everywhere</a></p>

<p><img src="/images/RFM98_thumb.jpg" alt="RFM98" title="RFM98" /></p>

<p>The RFM98 module above is assembled using my own low cost PCBs, in this case the Mikrobus module PCB is modified from standard to allow access to all the LoRa device DIO pins. The advantage of having a controller board that accepts Mikrobus modules is that it is easy to re-purpose the controller board simply by fitting a different type of Mikrobus module, see the Mikroelectronica link above for the possibilities.</p>

<p>But which ESP32 board to use ?  There are several, the Wemos Lolin 32 seems popular, but I really wanted to be able to plug in a choice of batteries and not be restricted to a Lithium battery. The NodeMcu32s fits the bill, its one of the smaller ESP32 boards and provides access to the voltage(battery) in pin. The board is shown below.</p>

<p><img src="/images/NodeMcu32s_thumb.jpg" alt="NodeMcu32s" title="NodeMcu32s" /></p>

<p>Designing a Mikrobus module PCB for the NodeMcu32s was easy enough, I use Eagle, but what had me stuck was which of the pins of the NodeMcu32s you could you use as inputs, outputs, interrupts or analogue and more importantly which pins did you need to avoid using for fear of interfering with the ESP32 itself or the attached flash.</p>

<p>I decided to design my board layout first and then check that I could get the functions I wanted out of the pins, the functions I needed were;</p>

<p>Outputs, flash an LED, drive a chip select.</p>

<p>Inputs, read a switch or interrupt.</p>

<p>Analogue, read a battery voltage for instance.</p>

<p>Pulse Width Modulation, not needed for my board, but useful for the Mikrobus sockets.</p>

<p>UART transmit and receive, two channels.</p>

<p>I2C, read and write to a FRAM and SSD1306 OLED display</p>

<p>Micro SD card read and write.</p>

<p>LoRa device, read and write</p>

<p>So as well as checking the basic pin functions, I needed test programs for each of the above to confirm it would all work in practice. After a couple of days of testing and checking I worked out which pins you can use on the NodeMcu32s and which ones to avoid, they are listed below, with comments against each pin.</p>

<p><img src="/images/esp__nodemcu-32s_pinout_thumb.jpg" alt="esp__nodemcu-32s_pinout" title="esp__nodemcu-32s_pinout" /></p>

<p>0 Input, shared with the IO0 switch on the board, this switch needs to be pressed, pin held low, to download a program</p>

<p>1 TX output from serial console, I made no connection to this pin</p>

<p>2 Output, shared with the LED on the board</p>

<p>3 RX input to serial console, I made no connection to this pin</p>

<p>4 Analogue, used to read battery level</p>

<p>5 Output, SPI SS, used for chip select on LoRa device</p>

<p>6 Could not use, appears to be used by flash</p>

<p>7 Could not use, appears to be used by flash</p>

<p>8 Could not use, appears to be used by flash</p>

<p>9 Could not use, appears to be used by flash</p>

<p>10 Could not use, appears to be used by flash</p>

<p>11 Could not use, appears to be used by flash</p>

<p>12 Input, can be used as a switch input, but be sure to leave it floating during programming. There is a pull up to VCC on the board and when this pin is high the correct voltage for the Flash is selected. If the pin is low programming will fail</p>

<p>13 Input, Serial1 RX, you can select any of the available input pins for the RX when defining the Serial1 instance</p>

<p>14 Input, Serial1 TX, you can select any of the available input pins for the TX when defining the Serial1 instance</p>

<p>15 Input and Output, LoRa device DIO2 interrupt input or PWM output</p>

<p>16 Input, Serial2 RX, you can select any of the available input pins for the RX when defining the Serial2 instance</p>

<p>17 Output, Serial2 TX, you can select any of the available input pins for the TX when defining the Serial2 instance</p>

<p>18 Output, SPI SCK, used for the LoRa device and SD card</p>

<p>19 Input, SPI MISO, used for the LoRa device and SD card</p>

<p>21 SDA, used for the SSD1306 display and I2C FRAM</p>

<p>21 SCL, used for the SSD1306 display and I2C FRAM</p>

<p>23 Output, SPI MOSI, used for the LoRa device and SD card</p>

<p>25 Output, used for chip select on SD card</p>

<p>26 Analogue, used to read battery level</p>

<p>27 Output, used for the RST on the LoRa device</p>

<p>32 Output, PWM</p>

<p>33 Input only, used for used for reading external switch</p>

<p>34 Input only, needs external pull-up, used for reading DIO1 on LoRa device</p>

<p>35 Input only, needs external pull-up, used for reading DIO0 on LoRa device</p>

<p>36 Input only, needs external pull-up, used for reading DIO3 on LoRa device</p>

<p>39 Input only, needs external pull-up, used for reading external switch</p>

<p>EN Input, External reset, pull to ground for reset.</p>

<p>VIN External power input. Intended supply is 4 x AA Alkaline or NiMh batteries.</p>

<p>It is not clear why pins 6 to 11 are provided on the board, you do not appear to be able to use them. These pins are not present on some other ESP32 boards such as the Wemos Lolin32.</p>

<p>Although the pin mappings above are the defaults for the NodeMcu32 board you can map the pins for SPI, I2C, UART or PWM to any available pins, although not 6,7,8,9,10,11,12. I have also not tried redirecting these interfaces to 34,35,36,37.</p>

<p>There are some capacitors associated with pins 36 (VP) and 39 (VN) but they did not appear to interfere with the relatively slow interrupts you will get from a LoRa device for instance.</p>

<p><strong>Program space</strong></p>

<p>I have a program that I use for LoRa link testing, it receives LoRa packets and logs the SNR, RSSI and contents to the Serial monitor and SD card. When compiled for an Arduino Pro Mini the program consumes this much space;</p>

<p><em>Sketch uses 19562 bytes (63%) of program storage space. Maximum is 30720 bytes.<br />
Global variables use 1292 bytes (63%) of dynamic memory, leaving 756 bytes for local variables. Maximum is 2048 bytes</em>.</p>

<p>For the NodeMcu32s it consumes this amount of space;</p>

<p><em>Sketch uses 159701 bytes (12%) of program storage space. Maximum is 1310720 bytes.<br />
Global variables use 12348 bytes (4%) of dynamic memory, leaving 282564 bytes for local variables. Maximum is 294912 bytes.</em></p>

<p>So although the NodeMcu32s reports as having 1,310,720 bytes of available Flash, compared to 30,720 for the Pro Mini, compiled ESP32 programs consume that space at around 8 times the rate for an ATMega328 program, so you don’t have as much usable program space as you might think.</p>

  </div><a class="u-url" href="/2018/03/22/adventures-with-the-esp32.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          
        </ul>
      </div>
      <div class="footer-col">
        <p>Adventures with Semtech LoRa devices</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
